---
title: "FishBae"
subtitle: "EEMB 595 Final Project" 
author: "Phoebe Racine & Erin Winslow"
date: "5/13/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Questions for Grace
1. What do we need to send Grace analysis wise?

2. Do we need to code in JAGS?
- we're considering just R and are considering STAN

3.The length of the presentation might be long considering where we're at vs. where the class is at. What might be more appropriate?

4. For a GLM, the book has us generate data. We don't have to do this since we have our own data correct?
- Do we need to generate C?
- What is set.seed()?

#Task List for Phoebe & Erin
- ~~copy/paste from Juanca~~
  - ~~figure out what data sources we need in order to create Bayesian regression~~
  - ~~I think we're at "fao_salmon_lobster.csv" & "all_salmon_lobster.csv"~~
  - beautify graph 
- ~~copy/paste GLM code from R~~
- read 3.3 of stats book
- research alpha/beta for GLMs
- figure out if we need to use random error graph
- what is C?
- update GLM code to fit out data needs
  - ~~select by salmon and lobster~~
- beautify regression table
- **combine Bay line w/ Juanca graph**
- consider including RAM legacy data if we want to provide a fuller story
  - consider analysis type
- Presentation
  - pull graphs from early AquaForce
  



#Loading Packages
```{r}
library(tidyverse)
library(stargazer)
library(ggplot2)

```


#Salmon and Lobster Code from Juanca


##Salmon-Lobster Graph
```{r}

fao_salmon_lobster  %>%
  group_by(year, source, general_name) %>% 
  summarize(quantity = sum(quantity)) %>% 
  filter(!(general_name == "Lobster" & source == "Aquaculture")) %>% 
  rename(Species = general_name) %>% 
  ggplot(aes(x = year, y = quantity/1000000, color = source, linetype = Species, group = paste(source, Species))) +
  geom_line(size = 1) +
  scale_color_brewer(palette = "Set1") +
  geom_vline(xintercept = 1962, linetype = "dashed") +
  geom_text(aes(x = 1975, y = 2.5, label = "Salmon aquaculture begins"), color = "black", size = 4) +
  labs(x = "Year", y = "Quantities (million MT)", caption = "(Data from FAO: www.fao.org/fishery/statistics/)") +
  theme_minimal()

```



#Code for GLM in R
**Poisson GLM in R and WinBUGS for modeling time series of counts**
The poisson GLM is described by a noise or random parameter following a Poisson distribution. In this sense, the random part of the response (or the statistical distribution) is given by:

Ci∼Poisson(λi)
Here, λi is the expected count (mean response) related to the response. It is the link between the systematic and stochastic parts of the GLM:
C = What is C?
i = number of years

log(λi)=ηiλi=eηi

And ηi is simply the linear predictor (the systematic or signal part of the response):

ηi=α+β∗Xi

Intuitively, α and β are the parameters of interest, and Xi represents the value of the covariate (predictor variable) X at year i.

###Visualizing the Random Error introduced through a Poisson Process
- *need to determine if this is important or nice to have*
```{r}

###everything needs to be switched out to fit our work
data_fn() %>% #need to change
  ggplot(aes(x = year, y = C)) +
  geom_line(aes(y = expected_count), size = 1) + 
  geom_point(shape = 21, fill = "steelblue", size = 4) +
  labs(x = "year", y = "Population size")


```
Black line represents the signal, blue dots represent the signal plus the random error introduced through a poisson process.



#Our Model
Count = "quantity"
Years = 65 years, 1950 --> 2015
Total data points: 13,293




###R Approach
In R, we apply a GLM using the glm function, to which we must specify the formula (the systematic part) and the name of the family that generates the error distribution.


```{r}


###everything needs to be switched out to fit our work
set.seed(43) #The set.seed you use is the starting number you use in a sequence of numbers from random generation. How should we pick the set.seed?

data <- data_fn()

fm <- glm(C ~ year + I(year^2) + I(year^3), family = "poisson", data = data)

stargazer::stargazer(fm,
                     type = "html",
                     header = F,
                     single.row = T,
                     intercept.bottom = F,
                     intercept.top = T)

data <- data_fn()

fm <- glm(C ~ year + I(year^2) + I(year^3), family = "poisson", data = data)

stargazer::stargazer(fm,
                     type = "html",
                     header = F,
                     single.row = T,
                     intercept.bottom = F,
                     intercept.top = T)


```

####Our test
```{r}

salmon_lobster <- fao_salmon_lobster %>%
  mutate(binary = ifelse(general_name == "Salmon", 1, 0))
# View(salmon_lobster)  

modeltestBAY <- glm(binary ~ quantity * year + I(year^2) + I(year^3), family = "poisson", data = salmon_lobster)
summary(modeltestBAY)

modeltestFREQ <- glm(binary ~ quantity * year, family = "binomial", data = salmon_lobster)
summary(modeltestFREQ)

stargazer::stargazer(modeltestBAY,
                     type = "html",
                     header = F,
                     single.row = T,
                     intercept.bottom = F,
                     intercept.top = T)



```
##Graphing our Model
```{r}


ggplot(salmon_lobster, aes(year, quantity)) + 
         geom_point() +
       stat_smooth(method=glm, family=poisson, se = F) #how do we tell it what model we're running?? #Family = binomial and family = poisson result in the same thing rn


```



###JAGS Approach
First, we need to specify the model
```{r}
sink(here::here("WinBUGS", "GLM_Poisson.txt"))

cat("
  model{
    # Priors
    alpha ~ dunif(-20, 20)
    beta1 ~ dunif(-10, 10)
    beta2 ~ dunif(-10, 10)
    beta3 ~ dunif(-10, 10)
    
    #Likelihood: Note key components of a GLM on one line each
    
    for(i in 1:n){
      C[i] ~ dpois(lambda[i]) # This is the distribution for random part
      log(lambda[i]) <- log.lambda[i] # This is the link function
      log.lambda[i] <- alpha + beta1*year[i] + beta2*pow(year[i], 2) + beta3*pow(year[i], 3) # This is the linear predictor
    }
  }"
  , fill = T)

sink()


```


We now bundle the data. Since our predictor (year) is bounded between 0 and 40 and we have a cubic term, we would have a huge number on one side of the yea vector (i.e. 403=64000), and small numbers on the other. We must center and scale our data. The best way to do this is by taking the years, substracting the mean and then dividing by the standard deviation.
```{r}

y_trans <- (data$year - mean(data$year)) / sd(data$year)

datab <- list(C = data$C, n = length(data$C), year = y_trans)

```

And define a function that returns random initial values
```{r}
inits <- function(){
  list(alpha = runif(1, -2, 2),
       beta1 = runif(1, -3, 3))
}

```

We need to specify a list of the quantities we want to estimate or measure. These are the parameters that WinBUGS should return
```{r}

params <- c("alpha", "beta1", "beta2", "beta3", "lambda")

```

We must also specify a series of MCMC settings, including the number of draws per chain, thinning rate, burnin length, and number of chains.

The settings are:

```{r}

ni <- 2000
nt <- 2
nb <- 1000
nc <- 3

```

We can now pass all these to WinBUGS
```{r}
set.seed(43)
out_jags <- jags(data = datab,
                 inits = inits,
                 parameters.to.save = params,
                 model.file = "GLM_poisson.txt",
                 n.chains = nc,
                 n.thin = nt,
                 n.iter = ni,
                 n.burnin = nb,
                 parallel = T)


```

```{r}
out_jags

```


#Considering Using RAM Data

##Load RAM Legacy database
```{r}
ram <- read.csv(here("raw_data","RAM", "RAM.csv"), stringsAsFactors = F) %>% 
  janitor::clean_names()

```

```{r}
lobster_salmon_ram <- ram %>% 
  mutate(lobster = grepl(pattern = "lobster", x = stocklong),
         salmon = grepl(pattern = "salmon", x = stocklong),
         general_name = case_when(lobster ~ "Lobster",
                                  TRUE ~ "Salmon")) %>% 
  filter(lobster | salmon,
         tsid == "BdivBmsytouse-dimensionless")

```

###Graph of RAM Salmon and Lobster data
```{r}

lobster_salmon_ram %>% 
  group_by(tsyear, general_name) %>% 
  summarize(tsvalue = median(tsvalue, na.rm = T)) %>% 
  ggplot(aes(x = tsyear, y = tsvalue, color = general_name, group = general_name)) +
  geom_line(size = 1) +
  theme_bw()

```



